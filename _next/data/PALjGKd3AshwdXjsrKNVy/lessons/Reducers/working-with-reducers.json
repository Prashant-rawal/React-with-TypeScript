{"pageProps":{"post":{"attributes":{},"html":"<h1 id=\"typing-reducers\"><strong>Typing Reducers</strong></h1>\n<br>\n\n<p>Let&#39;s head back over to our Accident Counter example</p>\n<p>We&#39;ve see how to use TypeScript with <code>useState</code>, but what about <code>useReducer</code>? It shouldn&#39;t be surprisng to find that a <em>lot</em> of it works out of the box, that said, there are still some additional features that we can take advantage of the make our lives easier.</p>\n<h2 id=\"refactoring-from-usestate-to-usereducer\">Refactoring from <code>useState</code> to <code>useReducer</code></h2>\n<p>There are a few ways that we could do this:</p>\n<ul>\n<li>Just create a super simple reducer that recieves a number and updates it accordingly. This is <em>super similar</em> to what we&#39;re doing with <code>useState</code>.</li>\n<li>Create and dispatch actions like we typically see when using <code>useReducer</code>.</li>\n</ul>\n<p>Since the goal it so get a deep understanding of how TypeScript works with React, let&#39;s try both, although you&#39;ll probably typically do the latter.</p>\n<h2 id=\"the-simplest-reducer\">The simplest reducer</h2>\n<p>This will <em>technically</em> do the trick.</p>\n<pre><code class=\"language-tsx\">const reducer = (count: number, newValue: number) =&gt; {\n  return newValue;\n};\n\nconst [count, setCount] = useReducer(reducer, 0);\n</code></pre>\n<p>There are a bunch of ways this could go wrong. What happens if we don&#39;t pass our new <code>setCount</code> a value? What if we don&#39;t give <code>useReducer</code> a default value? These are all reasonable converns that TypeScript has as well. Luckily, it will automatically protect us from writing code that hits either of the afformentioned oversights.</p>\n<p><img src=\"_attachments/Pasted%20image%2020221107091146.png\" alt=\"\">\n<img src=\"_attachments/Pasted%20image%2020221107091217.png\" alt=\"\"></p>\n<p>Okay, enough of that. Let&#39;s write a real reducer.</p>\n<h2 id=\"managing-the-current-and-draft-count-with-the-same-reducer\">Managing the current and draft count with the same reducer</h2>\n<p>Let&#39;s talk about what happens when we don&#39;t take advantage of TypeScript in this situation. Shall we? I didn&#39;t even do this on purpose, but I wrote up a super simple implementation to get us ready for this section.</p>\n<p>Here was my <code>reducer</code>:</p>\n<pre><code class=\"language-ts\">type InitialState = {\n  count: number;\n  draftCount: string | number;\n};\n\nconst initialState: InitialState = {\n  count: 0,\n  draftCount: 0,\n};\n\nconst reducer = (state = initialState, action: any) =&gt; {\n  const { count, draftCount } = state;\n\n  if (action.type === &quot;increment&quot;) {\n    const newCount = count + 1;\n    return { count: newCount, draftCount: newCount };\n  }\n\n  if (action.type === &quot;decrement&quot;) {\n    const newCount = count - 1;\n    return { count: newCount, draftCount: newCount };\n  }\n\n  if (action.type === &quot;reset&quot;) {\n    return { count: 0, draftCount: 0 };\n  }\n\n  if (action.type === &quot;updateDraftCount&quot;) {\n    console.log(&quot;updateDraftCount&quot;);\n\n    return { count, draftCount: action.payload };\n  }\n\n  if (action.type === &quot;updateCountFromDraft&quot;) {\n    return { count: Number(draftCount), draftCount };\n  }\n\n  return state;\n};\n</code></pre>\n<p>In the component itself, I wrote the following:</p>\n<pre><code class=\"language-tsx\">const Counter = () =&gt; {\n  const [{ count, draftCount }, dispatch] = useReducer(reducer, initialState);\n\n  return (\n    &lt;section className=&quot;flex flex-col items-center w-2/3 gap-8 p-8 bg-white border-4 shadow-lg border-primary-500&quot;&gt;\n      &lt;h1&gt;Days Since the Last Accident&lt;/h1&gt;\n      &lt;p className=&quot;text-6xl&quot;&gt;{count}&lt;/p&gt;\n      &lt;div className=&quot;flex gap-2&quot;&gt;\n        &lt;button onClick={() =&gt; dispatch({ type: &quot;decrement&quot; })}&gt;\n          ‚ûñ Decrement\n        &lt;/button&gt;\n        &lt;button onClick={() =&gt; dispatch({ type: &quot;reset&quot; })}&gt;üîÅ Reset&lt;/button&gt;\n        &lt;button onClick={() =&gt; dispatch({ type: &quot;increment&quot; })}&gt;\n          ‚ûï Increment\n        &lt;/button&gt;\n      &lt;/div&gt;\n      &lt;div&gt;\n        &lt;form\n          onSubmit={(e) =&gt; {\n            e.preventDefault();\n            dispatch({ type: &quot;updateCountFromDraft&quot; });\n          }}\n        &gt;\n          &lt;input\n            type=&quot;number&quot;\n            value={draftCount}\n            onChange={(e) =&gt;\n              dispatch({ action: &quot;updateDraftCount&quot;, payload: e.target.value })\n            }\n          /&gt;\n          &lt;button type=&quot;submit&quot;&gt;Update Counter&lt;/button&gt;\n        &lt;/form&gt;\n      &lt;/div&gt;\n    &lt;/section&gt;\n  );\n};\n</code></pre>\n<h3 id=\"enumerating-my-mistakes-and-other-issues\">Enumerating my mistakes and other issues</h3>\n<p>To be clear, I was intentionally doing this the hard way to make a point‚Äîit just turns out that I did an even better job of making my point than expected.</p>\n<p><img src=\"_attachments/Pasted%20image%2020221107100445.png\" alt=\"\"></p>\n<ul>\n<li>Updating the draft count doesn&#39;t work because I made a typo. I called the property <code>action</code> instead of</li>\n<li><code>count</code> is a number, but <code>draftCount</code> turned into <code>any</code>.<ul>\n<li>This is because <code>action</code> is any and the <code>draftCount</code> value comes into contact with my <code>action</code> and thereby get&#39;s infected with its <code>any</code>.</li>\n</ul>\n</li>\n</ul>\n<p>There are other things that <em>could</em> have gone wrong. For example, I spent a few minutes and a bunch of <code>console.log</code>s checking to see if I had mispelled one of the action names‚Äîbecause, that&#39;s absolutely happened to me before.</p>\n<p>It&#39;s kind of wild to see how one <code>any</code> could so wildly throw away all of the hard work we&#39;ve done up to this point.</p>\n<h2 id=\"refactoring-our-reducer\">Refactoring our reducer</h2>\n<p>The name of the game is getting ready of that pesky <code>any</code> and then reaping all of the rewards for our hard work.</p>\n<p>If an action is not <code>any</code> then what is it? Redux insists that action is an object and has a <code>type</code> property. As you saw with the simple example earlier, React&#39;s <code>useReducer</code> doesn&#39;t even care about that. It let us dispatch a number. But, let&#39;s set some ground rules and say we&#39;re going to follow something similar to <a href=\"https://github.com/redux-utilities/flux-standard-action\">Flux Standard Actions</a>.</p>\n<p>We&#39;ll say that at the very least, actions conform to this psuedocode interface:</p>\n<pre><code class=\"language-ts\">interface Action {\n  type: string;\n  payload?: unknown;\n}\n</code></pre>\n<p>Don&#39;t let that <code>unknown</code> scare you. This is just an example that we&#39;re not going to use. We&#39;ll bring this idea into reality in a bit, but let&#39;s solve the problem at hand first.</p>\n<p>(If you <em>really</em> want to know what I would do. You can peek at <a href=\"https://www.typescriptlang.org/play?#code/C4TwDgpgBAggxsAlgewHYB4AqUIA9gSoAmAzlCcAE6KoDmANFAApQC8UqEAbhJQHxsoAbwBQUKKEgAuKJgDcIgL5QAZFAAUAbSYBdHPkKkomzj0o6xUAPzDFlmaPFOoYAIYgANsldEZTBc6KAJQKIpLQAMLIAK6oBJQAysCuBIKOUHAxcTKo0QC2AEa8AVBElK4AZsBRscAyFNR0UAA+HPlFlAqKoeFQNXG88EhogkMoGJYA5DRwlBB5hMCTLVCTRBCz84vLrZNzJBBLK5PRYEQpEP3AAGKUyHkAIuVVkyJ8Cr0AqmcXT5XVWXiYxG7GBGBOPwIfyqV0mjFyhV4KwaNFo7xEIkyqAoUBmMiugwQ4zSEnAEBk01QmwWcWW3UxaBxp3OBBk3xZEGhANqhOGqDSlnCFOZv2e3Np9Esbk83l8UAALJL6QzscAoHMiNE4Ej2OpLBQLvjAbwkhdJeJXES0EaeZQwSt2aL-gS7VbUJKgmwBOkPIdhBlAYwys7AVBlOwDQRQuISAB3RDAOAACw0lr5ADpwp70uI4K4DqsZnMaUspJZnJlaoJK3EoABqKAARhKzjmwGilH5QgDtRkNeAQbFVz7ofpFfz0DWG2L2zLzlzofY-agAFomy2nG2O12e9ldwPSkPASOq2OnHmC3sIAdS+XN4dt-7+zIAAyDkO9qAvsMbi+TkVQketSTHO85bp2T6BoeH57mm4zptKXg+D+d5-qsAGXICtz3FyIF3uI4E7s+UAAHLtLw6jBjCgJBO+1GniUdj0kAA\">this</a>.)</p>\n<p>Let&#39;s let this reducer know about what kind of actions it can expect. If we look, it&#39;s handling the following:</p>\n<ul>\n<li><code>increment</code></li>\n<li><code>decrement</code></li>\n<li><code>reset</code></li>\n<li><code>updateDraftCount</code> (This one has a payload with the new value.)</li>\n<li><code>updateCountFromDraft</code></li>\n</ul>\n<p>Let&#39;s start by taking care of all of the actions that don&#39;t take a payload first. One of the problems with the fictitious interface that I defined above is that we don&#39;t really avoid the problem of mistyping a type.</p>\n<p>In JavaScript, we often see people use constants to get around this. If you misspell a string, the code still compiles; if you mispell a constant, everything blows up. That&#39;s one way to roll your own type safety, I suppose.</p>\n<pre><code class=\"language-js\">const INCREMENT = &quot;increment&quot;;\nconst DECREMENT = &quot;decrement&quot;;\n</code></pre>\n<p>I&#39;ve always hated this. Next thing you know, you&#39;re importing these constants all over the place. It&#39;s just a mess.</p>\n<p>Instead, let&#39;s try this:</p>\n<pre><code class=\"language-ts\">interface CounterAction {\n  type: &quot;increment&quot; | &quot;decrement&quot; | &quot;reset&quot; | &quot;updateCountFromDraft&quot;;\n}\n</code></pre>\n<p>We&#39;re now saying that an action can&#39;t just have <em>any</em> strings. It has to have one of the types that we know about. In a similar fashion, we can tell TypeScript about <code>updateDraftCount</code> and what kind of payload it&#39;s expecting.</p>\n<pre><code class=\"language-ts\">interface UpdateDraftCounterAction {\n  type: &quot;updateDraftCount&quot;;\n  payload: number | string;\n}\n</code></pre>\n<h3 id=\"updating-our-reducer-with-the-new-action-type\">Updating our reducer with the new action type</h3>\n<p>Let&#39;s get rid of that insipid <code>any</code> and replace it with our new types:</p>\n<pre><code class=\"language-ts\">const reducer = (\n  state = initialState,\n  action: CounterAction | UpdateDraftCounterAction\n) =&gt; {\n  // ‚Ä¶\n};\n</code></pre>\n<p>If you look closely, you can see that TypeScript saved me the trouble of logging to the console and immediate saw the error of my ways.</p>\n<p><img src=\"_attachments/Pasted%20image%2020221107103834.png\" alt=\"\"></p>\n<h3 id=\"taking-advantage-of-the-benefits\">Taking advantage of the benefits</h3>\n<p>It gets even better, because now we have autocomplete for anything involving this reducer and its actions.</p>\n<p>Let&#39;s imagine that I started with this approach and began to write my reducer with the type already defined.</p>\n<p><img src=\"_attachments/Pasted%20image%2020221107104045.png\" alt=\"\"></p>\n<p>There are two things to notice here:</p>\n<ol>\n<li>We get autocomplete.</li>\n<li><code>increment</code> is <em>not</em> included in that list.</li>\n</ol>\n<p><code>increment</code> is not included because we already handled that case above. As you add additional cases, the list will get shorter and shorted.</p>\n<h3 id=\"usage-with-switch-statements\">Usage with <code>switch</code> statements</h3>\n<p>As a matter of preference, I don&#39;t care for <code>switch</code> statements. But, there is something interesting to notice in the screenshort below.</p>\n<p><img src=\"_attachments/Pasted%20image%2020221107104717.png\" alt=\"\"></p>\n<p>You&#39;ll notice that <code>return state</code> is faded and TypeScript knows that we&#39;ll never reach that code because we&#39;ve handled all of the possible cases an <code>action.type</code> can be. It also doesn&#39;t insist we have a <code>default</code> case for the same reason.</p>\n<p>It will also help us as we use these actions in our components.</p>\n<p><img src=\"_attachments/Pasted%20image%2020221107104916.png\" alt=\"\"></p>\n<p>Additionally, if the action type expects a payload, TypeScript will ensure we don&#39;t forget about it.</p>\n<p><img src=\"_attachments/Pasted%20image%2020221107105035.png\" alt=\"\"></p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>Using TypeScript does add <em>some</em> additional work, but it also reduces‚Äîor maybe even‚Äîelimates the need for patters such as assigning action types to constants and action creators.</p>\n<p>You&#39;ll also noticed that I took care of coercing the potential string to a number in the reducer and I no longer need that <code>useEffect</code> that I apologized for in a previous section.</p>\n","markdown":"# **Typing Reducers**\n\n<br>\n\nLet's head back over to our Accident Counter example\n\nWe've see how to use TypeScript with `useState`, but what about `useReducer`? It shouldn't be surprisng to find that a _lot_ of it works out of the box, that said, there are still some additional features that we can take advantage of the make our lives easier.\n\n## Refactoring from `useState` to `useReducer`\n\nThere are a few ways that we could do this:\n\n- Just create a super simple reducer that recieves a number and updates it accordingly. This is _super similar_ to what we're doing with `useState`.\n- Create and dispatch actions like we typically see when using `useReducer`.\n\nSince the goal it so get a deep understanding of how TypeScript works with React, let's try both, although you'll probably typically do the latter.\n\n## The simplest reducer\n\nThis will _technically_ do the trick.\n\n```tsx\nconst reducer = (count: number, newValue: number) => {\n  return newValue;\n};\n\nconst [count, setCount] = useReducer(reducer, 0);\n```\n\nThere are a bunch of ways this could go wrong. What happens if we don't pass our new `setCount` a value? What if we don't give `useReducer` a default value? These are all reasonable converns that TypeScript has as well. Luckily, it will automatically protect us from writing code that hits either of the afformentioned oversights.\n\n![](_attachments/Pasted%20image%2020221107091146.png)\n![](_attachments/Pasted%20image%2020221107091217.png)\n\nOkay, enough of that. Let's write a real reducer.\n\n## Managing the current and draft count with the same reducer\n\nLet's talk about what happens when we don't take advantage of TypeScript in this situation. Shall we? I didn't even do this on purpose, but I wrote up a super simple implementation to get us ready for this section.\n\nHere was my `reducer`:\n\n```ts\ntype InitialState = {\n  count: number;\n  draftCount: string | number;\n};\n\nconst initialState: InitialState = {\n  count: 0,\n  draftCount: 0,\n};\n\nconst reducer = (state = initialState, action: any) => {\n  const { count, draftCount } = state;\n\n  if (action.type === \"increment\") {\n    const newCount = count + 1;\n    return { count: newCount, draftCount: newCount };\n  }\n\n  if (action.type === \"decrement\") {\n    const newCount = count - 1;\n    return { count: newCount, draftCount: newCount };\n  }\n\n  if (action.type === \"reset\") {\n    return { count: 0, draftCount: 0 };\n  }\n\n  if (action.type === \"updateDraftCount\") {\n    console.log(\"updateDraftCount\");\n\n    return { count, draftCount: action.payload };\n  }\n\n  if (action.type === \"updateCountFromDraft\") {\n    return { count: Number(draftCount), draftCount };\n  }\n\n  return state;\n};\n```\n\nIn the component itself, I wrote the following:\n\n```tsx\nconst Counter = () => {\n  const [{ count, draftCount }, dispatch] = useReducer(reducer, initialState);\n\n  return (\n    <section className=\"flex flex-col items-center w-2/3 gap-8 p-8 bg-white border-4 shadow-lg border-primary-500\">\n      <h1>Days Since the Last Accident</h1>\n      <p className=\"text-6xl\">{count}</p>\n      <div className=\"flex gap-2\">\n        <button onClick={() => dispatch({ type: \"decrement\" })}>\n          ‚ûñ Decrement\n        </button>\n        <button onClick={() => dispatch({ type: \"reset\" })}>üîÅ Reset</button>\n        <button onClick={() => dispatch({ type: \"increment\" })}>\n          ‚ûï Increment\n        </button>\n      </div>\n      <div>\n        <form\n          onSubmit={(e) => {\n            e.preventDefault();\n            dispatch({ type: \"updateCountFromDraft\" });\n          }}\n        >\n          <input\n            type=\"number\"\n            value={draftCount}\n            onChange={(e) =>\n              dispatch({ action: \"updateDraftCount\", payload: e.target.value })\n            }\n          />\n          <button type=\"submit\">Update Counter</button>\n        </form>\n      </div>\n    </section>\n  );\n};\n```\n\n### Enumerating my mistakes and other issues\n\nTo be clear, I was intentionally doing this the hard way to make a point‚Äîit just turns out that I did an even better job of making my point than expected.\n\n![](_attachments/Pasted%20image%2020221107100445.png)\n\n- Updating the draft count doesn't work because I made a typo. I called the property `action` instead of\n- `count` is a number, but `draftCount` turned into `any`.\n  - This is because `action` is any and the `draftCount` value comes into contact with my `action` and thereby get's infected with its `any`.\n\nThere are other things that _could_ have gone wrong. For example, I spent a few minutes and a bunch of `console.log`s checking to see if I had mispelled one of the action names‚Äîbecause, that's absolutely happened to me before.\n\nIt's kind of wild to see how one `any` could so wildly throw away all of the hard work we've done up to this point.\n\n## Refactoring our reducer\n\nThe name of the game is getting ready of that pesky `any` and then reaping all of the rewards for our hard work.\n\nIf an action is not `any` then what is it? Redux insists that action is an object and has a `type` property. As you saw with the simple example earlier, React's `useReducer` doesn't even care about that. It let us dispatch a number. But, let's set some ground rules and say we're going to follow something similar to [Flux Standard Actions](https://github.com/redux-utilities/flux-standard-action).\n\nWe'll say that at the very least, actions conform to this psuedocode interface:\n\n```ts\ninterface Action {\n  type: string;\n  payload?: unknown;\n}\n```\n\nDon't let that `unknown` scare you. This is just an example that we're not going to use. We'll bring this idea into reality in a bit, but let's solve the problem at hand first.\n\n(If you _really_ want to know what I would do. You can peek at [this](https://www.typescriptlang.org/play?#code/C4TwDgpgBAggxsAlgewHYB4AqUIA9gSoAmAzlCcAE6KoDmANFAApQC8UqEAbhJQHxsoAbwBQUKKEgAuKJgDcIgL5QAZFAAUAbSYBdHPkKkomzj0o6xUAPzDFlmaPFOoYAIYgANsldEZTBc6KAJQKIpLQAMLIAK6oBJQAysCuBIKOUHAxcTKo0QC2AEa8AVBElK4AZsBRscAyFNR0UAA+HPlFlAqKoeFQNXG88EhogkMoGJYA5DRwlBB5hMCTLVCTRBCz84vLrZNzJBBLK5PRYEQpEP3AAGKUyHkAIuVVkyJ8Cr0AqmcXT5XVWXiYxG7GBGBOPwIfyqV0mjFyhV4KwaNFo7xEIkyqAoUBmMiugwQ4zSEnAEBk01QmwWcWW3UxaBxp3OBBk3xZEGhANqhOGqDSlnCFOZv2e3Np9Esbk83l8UAALJL6QzscAoHMiNE4Ej2OpLBQLvjAbwkhdJeJXES0EaeZQwSt2aL-gS7VbUJKgmwBOkPIdhBlAYwys7AVBlOwDQRQuISAB3RDAOAACw0lr5ADpwp70uI4K4DqsZnMaUspJZnJlaoJK3EoABqKAARhKzjmwGilH5QgDtRkNeAQbFVz7ofpFfz0DWG2L2zLzlzofY-agAFomy2nG2O12e9ldwPSkPASOq2OnHmC3sIAdS+XN4dt-7+zIAAyDkO9qAvsMbi+TkVQketSTHO85bp2T6BoeH57mm4zptKXg+D+d5-qsAGXICtz3FyIF3uI4E7s+UAAHLtLw6jBjCgJBO+1GniUdj0kAA).)\n\nLet's let this reducer know about what kind of actions it can expect. If we look, it's handling the following:\n\n- `increment`\n- `decrement`\n- `reset`\n- `updateDraftCount` (This one has a payload with the new value.)\n- `updateCountFromDraft`\n\nLet's start by taking care of all of the actions that don't take a payload first. One of the problems with the fictitious interface that I defined above is that we don't really avoid the problem of mistyping a type.\n\nIn JavaScript, we often see people use constants to get around this. If you misspell a string, the code still compiles; if you mispell a constant, everything blows up. That's one way to roll your own type safety, I suppose.\n\n```js\nconst INCREMENT = \"increment\";\nconst DECREMENT = \"decrement\";\n```\n\nI've always hated this. Next thing you know, you're importing these constants all over the place. It's just a mess.\n\nInstead, let's try this:\n\n```ts\ninterface CounterAction {\n  type: \"increment\" | \"decrement\" | \"reset\" | \"updateCountFromDraft\";\n}\n```\n\nWe're now saying that an action can't just have _any_ strings. It has to have one of the types that we know about. In a similar fashion, we can tell TypeScript about `updateDraftCount` and what kind of payload it's expecting.\n\n```ts\ninterface UpdateDraftCounterAction {\n  type: \"updateDraftCount\";\n  payload: number | string;\n}\n```\n\n### Updating our reducer with the new action type\n\nLet's get rid of that insipid `any` and replace it with our new types:\n\n```ts\nconst reducer = (\n  state = initialState,\n  action: CounterAction | UpdateDraftCounterAction\n) => {\n  // ‚Ä¶\n};\n```\n\nIf you look closely, you can see that TypeScript saved me the trouble of logging to the console and immediate saw the error of my ways.\n\n![](_attachments/Pasted%20image%2020221107103834.png)\n\n### Taking advantage of the benefits\n\nIt gets even better, because now we have autocomplete for anything involving this reducer and its actions.\n\nLet's imagine that I started with this approach and began to write my reducer with the type already defined.\n\n![](_attachments/Pasted%20image%2020221107104045.png)\n\nThere are two things to notice here:\n\n1. We get autocomplete.\n1. `increment` is _not_ included in that list.\n\n`increment` is not included because we already handled that case above. As you add additional cases, the list will get shorter and shorted.\n\n### Usage with `switch` statements\n\nAs a matter of preference, I don't care for `switch` statements. But, there is something interesting to notice in the screenshort below.\n\n![](_attachments/Pasted%20image%2020221107104717.png)\n\nYou'll notice that `return state` is faded and TypeScript knows that we'll never reach that code because we've handled all of the possible cases an `action.type` can be. It also doesn't insist we have a `default` case for the same reason.\n\nIt will also help us as we use these actions in our components.\n\n![](_attachments/Pasted%20image%2020221107104916.png)\n\nAdditionally, if the action type expects a payload, TypeScript will ensure we don't forget about it.\n\n![](_attachments/Pasted%20image%2020221107105035.png)\n\n## Conclusion\n\nUsing TypeScript does add _some_ additional work, but it also reduces‚Äîor maybe even‚Äîelimates the need for patters such as assigning action types to constants and action creators.\n\nYou'll also noticed that I took care of coercing the potential string to a number in the reducer and I no longer need that `useEffect` that I apologized for in a previous section.\n","slug":"working-with-reducers","title":"Working with Reducers","section":"Reducers","icon":"recycle","filePath":"/home/runner/work/React-with-TypeScript/React-with-TypeScript/lessons/06-Reducers/A-working-with-reducers.md","nextSlug":"/React-with-TypeScript/lessons/Reducers/Passing-dispatch-as-a-prop","prevSlug":"/React-with-TypeScript/lessons/hooks/unions-in-typescript"}},"__N_SSG":true}