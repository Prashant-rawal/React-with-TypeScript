{"pageProps":{"post":{"attributes":{},"html":"<h1 id=\"usestate-exercise\"><strong>UseState Exercise</strong></h1>\n<br>\n\n<p>We&#39;ll start by creating some state to hold on to the value in the input field. I&#39;m going to base it on whatever the current count was when the component was first rendered, but you don&#39;t have to.</p>\n<pre><code class=\"language-tsx\">const [draftCount, setDraftCount] = useState(count);\n</code></pre>\n<p>I can <em>try</em> to add that as a change handler to the <code>&lt;input /&gt;</code>, but I already alluded to the fact that this isn&#39;t going to go particularly well.</p>\n<p>My annoyance with this behavior of the DOM may or may not become a recurring theme today.</p>\n<p>This is similar to what we saw before. The message reads:</p>\n<blockquote>\n<p>Argument of type <code>string</code> is not assignable to parameter of type <code>SetStateAction&lt;number&gt;</code>.</p>\n</blockquote>\n<p>The solution is straight-forward here. We need to coerce that value to a number. Choose your poison. You can use <code>parseInt</code>, <code>Number()</code>, or the <code>+</code> unary.</p>\n<pre><code class=\"language-ts\">setDraftCount(+e.target.value);\nsetDraftCount(parseInt(e.target.value));\nsetDraftCount(Number(e.target.value));\n</code></pre>\n<p>Now, we just update the <em>real</em> count to the draft count when we submit the form.</p>\n<pre><code class=\"language-ts\">&lt;form\n  onSubmit={(e) =&gt; {\n    e.preventDefault();\n    setCount(draftCount);\n  }}\n&gt;\n  // …\n&lt;/form&gt;\n</code></pre>\n<p>You&#39;ll see that this almost works. That input field is hard to clear out. An empty string coerces to zero. This isn&#39;t TypeScript&#39;s fault per se, but it&#39;s an issue that we&#39;ve run into because TypeScript is keeping us honest and making it harder to play fast and loose.</p>\n<p>We have a few options:</p>\n<ul>\n<li>We can store the draft state and convert it to a number when it&#39;s time to set the count. This is easy and we should totally do it.</li>\n<li>Even better: we can let <code>draftCount</code> be either a string or a number and then do that first bullet point.</li>\n</ul>\n<p>This <em>seems</em> tedious, but I will remind you that it&#39;s actually correct probably what we should be doing regardless.</p>\n<p>If we default it to a string, it&#39;s now a string.</p>\n<pre><code class=\"language-ts\">const [draftCount, setDraftCount] = useState(&quot;0&quot;);\n</code></pre>\n<p>The reason I don&#39;t love this is because I have to think about it if I want it to default to whatever the count is. Like, if I wanted to use a side effect to update the draft count in the input field whenever they hit the &quot;Increment&quot; or &quot;Decrement&quot; buttons, I&#39;m burdened with coercing it back into a string.</p>\n<p>This is particularly annoying because input fields don&#39;t care. Just look at it&#39;s type.</p>\n<pre><code class=\"language-ts\">React.InputHTMLAttributes&lt;HTMLInputElement&gt;.value?: string | number | readonly string[] | undefined\n</code></pre>\n<p>Amongst other things, it takes a <code>string | number</code>. We&#39;ll deal with that in a moment. Let&#39;s coerce that string into a number for the count, which totally needs to be a number before we forget.</p>\n<pre><code class=\"language-tsx\">&lt;form\n  onSubmit={(e) =&gt; {\n    e.preventDefault();\n    setCount(Number(draftCount));\n  }}\n&gt;\n  // …\n&lt;/form&gt;\n</code></pre>\n<p>We were taking advantage of TypeScript automatically figuring stuff out on our behalf, but the code we wrote is <em>really</em> just similar to this:</p>\n<pre><code class=\"language-ts\">const [count, setCount] = useState&lt;number&gt;(0);\nconst [draftCount, setDraftCount] = useState&lt;string&gt;(&quot;0&quot;);\n</code></pre>\n<p>We can take things into our own hands and update our draft state to support being either a string or a number.</p>\n<pre><code class=\"language-ts\">const [draftCount, setDraftCount] = useState&lt;string | number&gt;(0);\n</code></pre>\n<p>Now, everyhing works as expected.</p>\n<h2 id=\"extension-updating-the-draft-count\">Extension: updating the draft count</h2>\n<p>Just to make this all worth it, we can add that little extra feature we were talking about where the input field is updated to whatever the current count is.</p>\n<pre><code class=\"language-js\">useEffect(() =&gt; {\n  setDraftCount(count);\n}, [count]);\n</code></pre>\n<p>Look ma, no typing. Everything just works. Here is a fun fact that you can impress people at parties, there is an alternative take on this that <em>will</em> upset TypeScript.</p>\n<!-- ```ts\n// Reset the counter after a certain amount of time\nuseEffect(() => setTimeout(setCount(0), 31536000000));\n```\n\nThe error message reads:\n\n> Type `Timeout` is not assignable to type `void | Destructor`.\n\n`useEffect` expects the function you hand it to return either nothing or a function that it should call when the component is unmounting. There is code inside of React to defensively protect you from giving it something else. We've probably all written code like this before:\n\n```ts\nif (typeof fn === \"function\") fn();\n```\n\nBut, TypeScript's job is to try to reduce this burden on us. So, it's not even going to let you do that to React. Luckily, this fix is simple. Add back those curly braces to the function so that it doesn't automatically return a value.\n\n```ts\n// Reset the counter after a certain amount of time\nuseEffect(() => {\n  setTimeout(setCount(0), 31536000000);\n});\n```\n\nWe didn't run into that problem with `setDraftCount` because `setDraftCount` returns `void` (e.g. `undefined`) anyway. -->\n\n<h3 id=\"a-quick-disclaimer\">A quick disclaimer</h3>\n<p>React experts will know that using <code>useEffect</code> isn&#39;t great here because it could trigger a second render. One alternative is to just wrap <code>setCount</code> to do both at the same time. This is probably the best example, but I&#39;m most just trying to drum up fictitious reasons to show you the <code>useEffect</code> hook with TypeScript and it seemed more efficient to do it here than to set us up in a brand new example.</p>\n","markdown":"# **UseState Exercise**\n\n<br>\n\nWe'll start by creating some state to hold on to the value in the input field. I'm going to base it on whatever the current count was when the component was first rendered, but you don't have to.\n\n```tsx\nconst [draftCount, setDraftCount] = useState(count);\n```\n\nI can _try_ to add that as a change handler to the `<input />`, but I already alluded to the fact that this isn't going to go particularly well.\n\nMy annoyance with this behavior of the DOM may or may not become a recurring theme today.\n\nThis is similar to what we saw before. The message reads:\n\n> Argument of type `string` is not assignable to parameter of type `SetStateAction<number>`.\n\nThe solution is straight-forward here. We need to coerce that value to a number. Choose your poison. You can use `parseInt`, `Number()`, or the `+` unary.\n\n```ts\nsetDraftCount(+e.target.value);\nsetDraftCount(parseInt(e.target.value));\nsetDraftCount(Number(e.target.value));\n```\n\nNow, we just update the _real_ count to the draft count when we submit the form.\n\n```ts\n<form\n  onSubmit={(e) => {\n    e.preventDefault();\n    setCount(draftCount);\n  }}\n>\n  // …\n</form>\n```\n\nYou'll see that this almost works. That input field is hard to clear out. An empty string coerces to zero. This isn't TypeScript's fault per se, but it's an issue that we've run into because TypeScript is keeping us honest and making it harder to play fast and loose.\n\nWe have a few options:\n\n- We can store the draft state and convert it to a number when it's time to set the count. This is easy and we should totally do it.\n- Even better: we can let `draftCount` be either a string or a number and then do that first bullet point.\n\nThis _seems_ tedious, but I will remind you that it's actually correct probably what we should be doing regardless.\n\nIf we default it to a string, it's now a string.\n\n```ts\nconst [draftCount, setDraftCount] = useState(\"0\");\n```\n\nThe reason I don't love this is because I have to think about it if I want it to default to whatever the count is. Like, if I wanted to use a side effect to update the draft count in the input field whenever they hit the \"Increment\" or \"Decrement\" buttons, I'm burdened with coercing it back into a string.\n\nThis is particularly annoying because input fields don't care. Just look at it's type.\n\n```ts\nReact.InputHTMLAttributes<HTMLInputElement>.value?: string | number | readonly string[] | undefined\n```\n\nAmongst other things, it takes a `string | number`. We'll deal with that in a moment. Let's coerce that string into a number for the count, which totally needs to be a number before we forget.\n\n```tsx\n<form\n  onSubmit={(e) => {\n    e.preventDefault();\n    setCount(Number(draftCount));\n  }}\n>\n  // …\n</form>\n```\n\nWe were taking advantage of TypeScript automatically figuring stuff out on our behalf, but the code we wrote is _really_ just similar to this:\n\n```ts\nconst [count, setCount] = useState<number>(0);\nconst [draftCount, setDraftCount] = useState<string>(\"0\");\n```\n\nWe can take things into our own hands and update our draft state to support being either a string or a number.\n\n```ts\nconst [draftCount, setDraftCount] = useState<string | number>(0);\n```\n\nNow, everyhing works as expected.\n\n## Extension: updating the draft count\n\nJust to make this all worth it, we can add that little extra feature we were talking about where the input field is updated to whatever the current count is.\n\n```js\nuseEffect(() => {\n  setDraftCount(count);\n}, [count]);\n```\n\nLook ma, no typing. Everything just works. Here is a fun fact that you can impress people at parties, there is an alternative take on this that _will_ upset TypeScript.\n\n<!-- ```ts\n// Reset the counter after a certain amount of time\nuseEffect(() => setTimeout(setCount(0), 31536000000));\n```\n\nThe error message reads:\n\n> Type `Timeout` is not assignable to type `void | Destructor`.\n\n`useEffect` expects the function you hand it to return either nothing or a function that it should call when the component is unmounting. There is code inside of React to defensively protect you from giving it something else. We've probably all written code like this before:\n\n```ts\nif (typeof fn === \"function\") fn();\n```\n\nBut, TypeScript's job is to try to reduce this burden on us. So, it's not even going to let you do that to React. Luckily, this fix is simple. Add back those curly braces to the function so that it doesn't automatically return a value.\n\n```ts\n// Reset the counter after a certain amount of time\nuseEffect(() => {\n  setTimeout(setCount(0), 31536000000);\n});\n```\n\nWe didn't run into that problem with `setDraftCount` because `setDraftCount` returns `void` (e.g. `undefined`) anyway. -->\n\n### A quick disclaimer\n\nReact experts will know that using `useEffect` isn't great here because it could trigger a second render. One alternative is to just wrap `setCount` to do both at the same time. This is probably the best example, but I'm most just trying to drum up fictitious reasons to show you the `useEffect` hook with TypeScript and it seemed more efficient to do it here than to set us up in a brand new example.\n","slug":"useState-Solution","title":"useState Solution","section":"Hooks","icon":"hammer","filePath":"/home/runner/work/React-with-TypeScript/React-with-TypeScript/lessons/05-hooks/C-useState-Solution.md","nextSlug":"/React-with-TypeScript/lessons/hooks/setting-State-without-default-value","prevSlug":"/React-with-TypeScript/lessons/hooks/useState-exercise"}},"__N_SSG":true}