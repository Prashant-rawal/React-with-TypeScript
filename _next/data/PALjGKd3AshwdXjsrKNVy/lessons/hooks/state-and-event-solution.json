{"pageProps":{"post":{"attributes":{},"html":"<h2 id=\"solutions\"><strong>Solutions</strong></h2>\n<p>Let&#39;s start by getting rid of the hard-coded data and replacing it with some state.</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">const</span> [quotes, setQuotes] = <span class=\"hljs-title function_\">useState</span>([]);\n</code></pre>\n<p>You&#39;ll see have a bit of an issue here. Using an empty array should work in JavaScript, but TypeScript doesn&#39;t have enought information to do it&#39;s job and it assigns <code>quotes</code> to the following type:</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">quotes</span>: <span class=\"hljs-built_in\">never</span>[];\n</code></pre>\n<h2 id=\"a-similar-problem-with-arrays\">A similar problem with arrays</h2>\n<p>The code won&#39;t compile and we&#39;ll get the following error:</p>\n<blockquote>\n<p>Property &#39;content&#39; does not exist on type &#39;never&#39;.</p>\n</blockquote>\n<p>This kind of makes sense if we follow along with the rational that we&#39;ve been establishing, right? Consider theses lines:</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">const</span> [quote, setQuote] = <span class=\"hljs-title function_\">useState</span>();\n<span class=\"hljs-keyword\">const</span> [quotes, useQuotes] = <span class=\"hljs-title function_\">useState</span>([]);\n</code></pre>\n<p>With the array, it has no idea what it could possibly contain. It just assumes that it&#39;ll be a forever empty array.</p>\n<p>Then we move on to this line:</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">if</span> (!quote) <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Loading</span> /&gt;</span></span>;\n</code></pre>\n<p>Okay, quote is falsy, which <code>undefined</code> <em>is</em>, then show the <code>&lt;Loading /&gt;</code> component. Well, if <code>quote</code> is undefined and we handled the case where <code>quote</code> is <code>undefined</code>, then as we move along in the code, <code>quote</code> can&#39;t be <code>undefined</code> anymore and we&#39;re out of options. So, TypeScript assigns it a special type: <code>never</code>.</p>\n<p><code>never</code> is the lowest common demoninator and <em>certainly</em> doesn&#39;t have a property like <code>content</code> or <code>source</code> on in—mostly, because it doesn&#39;t have <em>anything</em>.</p>\n<p>Luckily, we know how to handle this.</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">const</span> [quotes, setQuotes] = useState&lt;<span class=\"hljs-title class_\">Quote</span>[]&gt;([]);\n</code></pre>\n<p>We&#39;ll also add some state for the count. This doesn&#39;t require anything special on our part and should just work. Pick a number that makes you happy.</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">const</span> [quotes, setQuotes] = useState&lt;<span class=\"hljs-title class_\">Quote</span>[]&gt;([]);\n<span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">10</span>);\n</code></pre>\n<h2 id=\"passing-in-the-count-and-loading-quotes\">Passing in the count and loading quotes</h2>\n<p>Now that we have a value that represents the number of quotes that we want to load, we can pass that into the <code>&lt;Quotes /&gt;</code> component.</p>\n<pre><code class=\"hljs language-tsx\">&lt;<span class=\"hljs-title class_\">Quotes</span> count={count}&gt;<span class=\"hljs-comment\">/* … */</span>&lt;/<span class=\"hljs-title class_\">Quotes</span>&gt;\n</code></pre>\n<h2 id=\"changing-the-count\">Changing the count</h2>\n<p>Our inclination would be to try something like this:</p>\n<pre><code class=\"hljs language-tsx\">&lt;<span class=\"hljs-title class_\">Quotes</span> count={count} onChange={<span class=\"hljs-function\">(<span class=\"hljs-params\">e</span>) =&gt;</span> <span class=\"hljs-title function_\">setCount</span>(+e.<span class=\"hljs-property\">target</span>.<span class=\"hljs-property\">value</span>)}&gt;\n</code></pre>\n<p>And that&#39;s a good inclination, but we haven&#39;t done the requisite work on the types inside of that component just yet.</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ChangeEventHandler</span>, <span class=\"hljs-title class_\">FormEventHandler</span>, <span class=\"hljs-title class_\">PropsWithChildren</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n\n<span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">QuotesProps</span> = {\n  <span class=\"hljs-attr\">count</span>: <span class=\"hljs-built_in\">number</span>;\n  onChange?: <span class=\"hljs-title class_\">ChangeEventHandler</span>&lt;<span class=\"hljs-title class_\">HTMLInputElement</span>&gt;;\n  <span class=\"hljs-attr\">onSubmit</span>: <span class=\"hljs-title class_\">FormEventHandler</span>&lt;<span class=\"hljs-title class_\">HTMLFormElement</span>&gt;;\n};\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Quotes</span> = (<span class=\"hljs-params\">{\n  children,\n  count,\n  onSubmit,\n  onChange,\n}: PropsWithChildren&lt;QuotesProps&gt;</span>) =&gt; {\n  <span class=\"hljs-comment\">// …</span>\n};\n</code></pre>\n<p>We also need to add the <code>onSubmit</code> event handler before it will compile, but that seems like a totally reasonable request, right?</p>\n<h2 id=\"submitting-the-form\">Submitting the form</h2>\n<p>Hmm, we clearly need to break out the ability to fetch posts out of the <code>useEvent</code> hook.</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-title function_\">fetchQuotes</span>(count).<span class=\"hljs-title function_\">then</span>(setQuotes);\n}, [count]);\n</code></pre>\n<p>We might feel fancy and try to do something like this to get that initial count.</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">fetchPosts</span>(count), []);\n</code></pre>\n<p><strong>Quick side note</strong>: You&#39;ll notice that the code will <em>not</em> compile if you omit the curly braces.</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">fetchPosts</span> = (<span class=\"hljs-params\">count: <span class=\"hljs-built_in\">number</span></span>) =&gt;\n  <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">`/api/quotes?limit=<span class=\"hljs-subst\">${count}</span>`</span>)\n    .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> res.<span class=\"hljs-title function_\">json</span>())\n    .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">{ quotes }</span>) =&gt;</span> <span class=\"hljs-title function_\">setQuotes</span>(quotes));\n</code></pre>\n<p>This won&#39;t work because <code>useEffect</code> expects thst either nothing is returned <em>or</em> a function that it will call when the component it can call when it unmounts. We need to make sure that the function returns <code>void</code> (e.g. <code>undefined</code>) instead.</p>\n<pre><code class=\"hljs language-tsx\">&lt;<span class=\"hljs-title class_\">Quotes</span>\n  count={count}\n  onChange={<span class=\"hljs-function\">(<span class=\"hljs-params\">e</span>) =&gt;</span> <span class=\"hljs-title function_\">setCount</span>(+e.<span class=\"hljs-property\">target</span>.<span class=\"hljs-property\">value</span>)}\n  onSubmit={<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">fetchPosts</span>(count)}\n&gt;&lt;/<span class=\"hljs-title class_\">Quotes</span>&gt;\n</code></pre>\n","markdown":"## **Solutions**\n\nLet's start by getting rid of the hard-coded data and replacing it with some state.\n\n```ts\nconst [quotes, setQuotes] = useState([]);\n```\n\nYou'll see have a bit of an issue here. Using an empty array should work in JavaScript, but TypeScript doesn't have enought information to do it's job and it assigns `quotes` to the following type:\n\n```ts\nconst quotes: never[];\n```\n\n## A similar problem with arrays\n\nThe code won't compile and we'll get the following error:\n\n> Property 'content' does not exist on type 'never'.\n\nThis kind of makes sense if we follow along with the rational that we've been establishing, right? Consider theses lines:\n\n```ts\nconst [quote, setQuote] = useState();\nconst [quotes, useQuotes] = useState([]);\n```\n\nWith the array, it has no idea what it could possibly contain. It just assumes that it'll be a forever empty array.\n\nThen we move on to this line:\n\n```ts\nif (!quote) return <Loading />;\n```\n\nOkay, quote is falsy, which `undefined` _is_, then show the `<Loading />` component. Well, if `quote` is undefined and we handled the case where `quote` is `undefined`, then as we move along in the code, `quote` can't be `undefined` anymore and we're out of options. So, TypeScript assigns it a special type: `never`.\n\n`never` is the lowest common demoninator and _certainly_ doesn't have a property like `content` or `source` on in—mostly, because it doesn't have _anything_.\n\nLuckily, we know how to handle this.\n\n```ts\nconst [quotes, setQuotes] = useState<Quote[]>([]);\n```\n\nWe'll also add some state for the count. This doesn't require anything special on our part and should just work. Pick a number that makes you happy.\n\n```ts\nconst [quotes, setQuotes] = useState<Quote[]>([]);\nconst [count, setCount] = useState(10);\n```\n\n## Passing in the count and loading quotes\n\nNow that we have a value that represents the number of quotes that we want to load, we can pass that into the `<Quotes />` component.\n\n```tsx\n<Quotes count={count}>/* … */</Quotes>\n```\n\n## Changing the count\n\nOur inclination would be to try something like this:\n\n```tsx\n<Quotes count={count} onChange={(e) => setCount(+e.target.value)}>\n```\n\nAnd that's a good inclination, but we haven't done the requisite work on the types inside of that component just yet.\n\n```tsx\nimport { ChangeEventHandler, FormEventHandler, PropsWithChildren } from \"react\";\n\ntype QuotesProps = {\n  count: number;\n  onChange?: ChangeEventHandler<HTMLInputElement>;\n  onSubmit: FormEventHandler<HTMLFormElement>;\n};\n\nconst Quotes = ({\n  children,\n  count,\n  onSubmit,\n  onChange,\n}: PropsWithChildren<QuotesProps>) => {\n  // …\n};\n```\n\nWe also need to add the `onSubmit` event handler before it will compile, but that seems like a totally reasonable request, right?\n\n## Submitting the form\n\nHmm, we clearly need to break out the ability to fetch posts out of the `useEvent` hook.\n\n```ts\nuseEffect(() => {\n  fetchQuotes(count).then(setQuotes);\n}, [count]);\n```\n\nWe might feel fancy and try to do something like this to get that initial count.\n\n```tsx\nuseEffect(() => fetchPosts(count), []);\n```\n\n**Quick side note**: You'll notice that the code will _not_ compile if you omit the curly braces.\n\n```tsx\nconst fetchPosts = (count: number) =>\n  fetch(`/api/quotes?limit=${count}`)\n    .then((res) => res.json())\n    .then(({ quotes }) => setQuotes(quotes));\n```\n\nThis won't work because `useEffect` expects thst either nothing is returned _or_ a function that it will call when the component it can call when it unmounts. We need to make sure that the function returns `void` (e.g. `undefined`) instead.\n\n```tsx\n<Quotes\n  count={count}\n  onChange={(e) => setCount(+e.target.value)}\n  onSubmit={() => fetchPosts(count)}\n></Quotes>\n```\n","slug":"state-and-event-solution","title":"State and Event Solution","section":"Hooks","icon":"hammer","filePath":"/home/runner/work/React-with-TypeScript/React-with-TypeScript/lessons/05-hooks/F-state-and-event-solution.md","nextSlug":"/React-with-TypeScript/lessons/hooks/passing-setState-and-reusing-state","prevSlug":"/React-with-TypeScript/lessons/hooks/state-and-event-exercise"}},"__N_SSG":true}