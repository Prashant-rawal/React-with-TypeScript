{"pageProps":{"post":{"attributes":{},"html":"<h1 id=\"passing-setstate-and-reusing-state-solution\"><strong>Passing setState and reusing State solution</strong></h1>\n<br>\nFirst off, I desperately want to get rid of that `any` for `setFilters` in `<QuoteFilter />`. If I have taught you anything so far, it's that hovering stuff is a useful technique.\n\n<p>If we hover over <code>setFilters</code>, we&#39;ll see the following:</p>\n<pre><code class=\"language-ts\">React.Dispatch&lt;\n  React.SetStateAction&lt;{\n    content: string;\n    source: string;\n  }&gt;\n&gt;;\n</code></pre>\n<p>That&#39;s the type for <code>setFilters</code>. Cool. We can totally use that in <code>&lt;QuoteFilter /&gt;</code> as is. Typing this correctly means that we can totally get rid of the <code>any</code> type defintion when updating those filters.</p>\n<pre><code class=\"language-diff\">@@ -1,6 +1,11 @@\n type QuoteFilterProps = {\n   filters: QuoteFilters;\n-  setFilters: any; // Change me!\n+  setFilters: React.Dispatch&lt;\n+    React.SetStateAction&lt;{\n+      content: string;\n+      source: string;\n+    }&gt;\n+  &gt;;\n };\n\n const QuoteFilter = ({ filters, setFilters }: QuoteFilterProps) =&gt; {\n@@ -13,7 +18,7 @@ const QuoteFilter = ({ filters, setFilters }: QuoteFilterProps) =&gt; {\n           name=&quot;content&quot;\n           value={filters.content}\n           onChange={(e) =&gt;\n-            setFilters((filters: any /* Ugh. */) =&gt; ({\n+            setFilters((filters) =&gt; ({\n               ...filters,\n               [e.target.name]: e.target.value,\n             }))\n@@ -29,7 +34,7 @@ const QuoteFilter = ({ filters, setFilters }: QuoteFilterProps) =&gt; {\n           name=&quot;source&quot;\n           value={filters.source}\n           onChange={(e) =&gt;\n-            setFilters((filters: any /* Ugh. */) =&gt; ({\n+            setFilters((filters) =&gt; ({\n               ...filters,\n               [e.target.name]: e.target.value,\n             }))\n</code></pre>\n<h2 id=\"using-a-better-type-for-setstateaction\">Using a better type for <code>SetStateAction</code></h2>\n<p>But, like…</p>\n<pre><code class=\"language-ts\">React.Dispatch&lt;\n  React.SetStateAction&lt;{\n    content: string;\n    source: string;\n  }&gt;\n&gt;;\n</code></pre>\n<p>…is a bit cumbersome, right? And, we know that <code>QuoteFilters</code> looks like this:</p>\n<pre><code class=\"language-ts\">type QuoteFilters = {\n  content: string;\n  source: string;\n};\n</code></pre>\n<p>This means, we could shorten <code>setFilters</code> to:</p>\n<pre><code class=\"language-ts\">type QuoteFilterProps = {\n  filters: QuoteFilters;\n  setFilters: React.Dispatch&lt;React.SetStateAction&lt;QuoteFilters&gt;&gt;;\n};\n</code></pre>\n<p>And if, we want to pull in React, we can get it down to:</p>\n<pre><code class=\"language-ts\">import type { Dispatch, SetStateAction } from &quot;react&quot;;\n\ntype QuoteFilterProps = {\n  filters: QuoteFilters;\n  setFilters: Dispatch&lt;SetStateAction&lt;QuoteFilters&gt;&gt;;\n};\n</code></pre>\n<p>Not bad.</p>\n<h2 id=\"getting-rid-of-the-duplicative-event-handlers\">Getting rid of the duplicative event handlers</h2>\n<p>I didn&#39;t love having to edit two event handlers that basically did the same thing. Let&#39;s pull them up.</p>\n<pre><code class=\"language-ts\">const handleChange = (e) =&gt; {\n  setFilters((filters) =&gt; ({\n    ...filters,\n    [e.target.name]: e.target.value,\n  }));\n};\n</code></pre>\n<p>Ugh, now our event—<code>e</code>—is <code>any</code>. Well, it&#39;s a event handler called when we change the event, right? Let&#39;s try this:</p>\n<pre><code class=\"language-ts\">const handleChange = (e: ChangeEvent) =&gt; {\n  setFilters((filters) =&gt; ({\n    ...filters,\n    [e.target.name]: e.target.value,\n  }));\n};\n</code></pre>\n<p>I mean, we solved the problem. It&#39;s just that we created new problems along the way. This is because not all events have <code>event.target</code> and we didn&#39;t tell React that we were dealing with <code>HTMLInputElement</code>s.</p>\n<p>Let&#39;s hover over that <code>onChange</code> we left behind and see what we get.</p>\n<p>On, look. React thinks that <code>onChange</code> props are the following type:</p>\n<pre><code class=\"language-ts\">React.ChangeEventHandler&lt;HTMLInputElement&gt; | undefined;\n</code></pre>\n<p>And because it knows the function is <em>supposed</em> to be that type, it takes what we passed it inline and as long as it fits that descript types our callback appropriately.</p>\n<p>Let&#39;s take advantage of the same idea:</p>\n<pre><code class=\"language-ts\">const handleChange: ChangeEventHandler&lt;HTMLInputElement&gt; = (e) =&gt; {\n  setFilters((filters) =&gt; ({\n    ...filters,\n    [e.target.name]: e.target.value,\n  }));\n};\n</code></pre>\n<p><strong>An alterative, but less good, approach</strong>: This will <em>also</em> work, but I like the above approach more because it fits in nicely with how we typed props earlier. I like not having to do things in different ways if I can avoid it.</p>\n<pre><code class=\"language-ts\">const handleChange = (e: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {\n  setFilters((filters) =&gt; ({\n    ...filters,\n    [e.target.name]: e.target.value,\n  }));\n};\n</code></pre>\n","markdown":"# **Passing setState and reusing State solution**\n\n<br>\nFirst off, I desperately want to get rid of that `any` for `setFilters` in `<QuoteFilter />`. If I have taught you anything so far, it's that hovering stuff is a useful technique.\n\nIf we hover over `setFilters`, we'll see the following:\n\n```ts\nReact.Dispatch<\n  React.SetStateAction<{\n    content: string;\n    source: string;\n  }>\n>;\n```\n\nThat's the type for `setFilters`. Cool. We can totally use that in `<QuoteFilter />` as is. Typing this correctly means that we can totally get rid of the `any` type defintion when updating those filters.\n\n```diff\n@@ -1,6 +1,11 @@\n type QuoteFilterProps = {\n   filters: QuoteFilters;\n-  setFilters: any; // Change me!\n+  setFilters: React.Dispatch<\n+    React.SetStateAction<{\n+      content: string;\n+      source: string;\n+    }>\n+  >;\n };\n\n const QuoteFilter = ({ filters, setFilters }: QuoteFilterProps) => {\n@@ -13,7 +18,7 @@ const QuoteFilter = ({ filters, setFilters }: QuoteFilterProps) => {\n           name=\"content\"\n           value={filters.content}\n           onChange={(e) =>\n-            setFilters((filters: any /* Ugh. */) => ({\n+            setFilters((filters) => ({\n               ...filters,\n               [e.target.name]: e.target.value,\n             }))\n@@ -29,7 +34,7 @@ const QuoteFilter = ({ filters, setFilters }: QuoteFilterProps) => {\n           name=\"source\"\n           value={filters.source}\n           onChange={(e) =>\n-            setFilters((filters: any /* Ugh. */) => ({\n+            setFilters((filters) => ({\n               ...filters,\n               [e.target.name]: e.target.value,\n             }))\n```\n\n## Using a better type for `SetStateAction`\n\nBut, like…\n\n```ts\nReact.Dispatch<\n  React.SetStateAction<{\n    content: string;\n    source: string;\n  }>\n>;\n```\n\n…is a bit cumbersome, right? And, we know that `QuoteFilters` looks like this:\n\n```ts\ntype QuoteFilters = {\n  content: string;\n  source: string;\n};\n```\n\nThis means, we could shorten `setFilters` to:\n\n```ts\ntype QuoteFilterProps = {\n  filters: QuoteFilters;\n  setFilters: React.Dispatch<React.SetStateAction<QuoteFilters>>;\n};\n```\n\nAnd if, we want to pull in React, we can get it down to:\n\n```ts\nimport type { Dispatch, SetStateAction } from \"react\";\n\ntype QuoteFilterProps = {\n  filters: QuoteFilters;\n  setFilters: Dispatch<SetStateAction<QuoteFilters>>;\n};\n```\n\nNot bad.\n\n## Getting rid of the duplicative event handlers\n\nI didn't love having to edit two event handlers that basically did the same thing. Let's pull them up.\n\n```ts\nconst handleChange = (e) => {\n  setFilters((filters) => ({\n    ...filters,\n    [e.target.name]: e.target.value,\n  }));\n};\n```\n\nUgh, now our event—`e`—is `any`. Well, it's a event handler called when we change the event, right? Let's try this:\n\n```ts\nconst handleChange = (e: ChangeEvent) => {\n  setFilters((filters) => ({\n    ...filters,\n    [e.target.name]: e.target.value,\n  }));\n};\n```\n\nI mean, we solved the problem. It's just that we created new problems along the way. This is because not all events have `event.target` and we didn't tell React that we were dealing with `HTMLInputElement`s.\n\nLet's hover over that `onChange` we left behind and see what we get.\n\nOn, look. React thinks that `onChange` props are the following type:\n\n```ts\nReact.ChangeEventHandler<HTMLInputElement> | undefined;\n```\n\nAnd because it knows the function is _supposed_ to be that type, it takes what we passed it inline and as long as it fits that descript types our callback appropriately.\n\nLet's take advantage of the same idea:\n\n```ts\nconst handleChange: ChangeEventHandler<HTMLInputElement> = (e) => {\n  setFilters((filters) => ({\n    ...filters,\n    [e.target.name]: e.target.value,\n  }));\n};\n```\n\n**An alterative, but less good, approach**: This will _also_ work, but I like the above approach more because it fits in nicely with how we typed props earlier. I like not having to do things in different ways if I can avoid it.\n\n```ts\nconst handleChange = (e: ChangeEvent<HTMLInputElement>) => {\n  setFilters((filters) => ({\n    ...filters,\n    [e.target.name]: e.target.value,\n  }));\n};\n```\n","slug":"passing-setState-and-resuing-state-solution","title":"Passing setState and Resuing State Solution","section":"Hooks","icon":"hammer","filePath":"/home/runner/work/React-with-TypeScript/React-with-TypeScript/lessons/05-hooks/H-passing-setState-and-resuing-state-solution.md","nextSlug":"/React-with-TypeScript/lessons/hooks/unions-in-typescript","prevSlug":"/React-with-TypeScript/lessons/hooks/passing-setState-and-reusing-state"}},"__N_SSG":true}