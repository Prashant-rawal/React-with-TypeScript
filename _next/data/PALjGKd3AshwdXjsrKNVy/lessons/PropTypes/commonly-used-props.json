{"pageProps":{"post":{"attributes":{},"html":"<p>Let&#39;s take a moment to look at some of the types that go along with some of the more common props that we tend to see in React applications.</p>\n<h2 id=\"primitives\">Primitives</h2>\n<p>For starters, we have our basic primitives.</p>\n<pre><code class=\"language-ts\">type CounterProps = {\n  incident: string;\n  count: number;\n  enabled: boolean;\n};\n</code></pre>\n<h2 id=\"arrays\">Arrays</h2>\n<p>We can also have arrays or collections of primitives.</p>\n<pre><code class=\"language-ts\">type GroceryListProps = {\n  items: string[];\n};\n</code></pre>\n<h2 id=\"unions-and-intersections\">Unions and intersections</h2>\n<p>Sometimes, we don&#39;t want to allowÂ <em>any</em>Â stringâ€”only certain strings. We can use aÂ <a href=\"https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html\">union type</a>Â to represent this.</p>\n<pre><code class=\"language-ts\">type GroceryListProps = {\n  items: string[];\n  status: &quot;loading&quot; | &quot;error&quot; | &quot;success&quot;;\n};\n</code></pre>\n<p><strong>Let the record show</strong>: This is one of my favorite things about using TypeScript in React. I don&#39;t want to talk about how many hours of my life I&#39;ve lossed due to a silly misspelling.</p>\n<h2 id=\"objects\">Objects</h2>\n<p>It&#39;s not uncommon for us to find ourselves using objects in JavaScript (ummm, TypeScript). So, what would that look like?</p>\n<pre><code class=\"language-ts\">type ContrivedExampleComponmentProps = {\n  anObject: object; // Useful as a placeholder.\n  anotherObject: {}; // Can have any properties and values.\n  yetAnotherObject: Record&lt;string, string&gt;;\n  // ðŸ‘† Takes an object where the keys are strings and so are the values.\n  item: {\n    id: string;\n    title: string;\n  };\n  items: {\n    id: string;\n    title: string;\n  }[]; // An array of objects of a certain shape.\n};\n</code></pre>\n<p>We could refactor this a bit. (I know, it&#39;s a contrived example, but go along with it.)</p>\n<pre><code class=\"language-ts\">type Item = {\n  id: string;\n  title: string;\n};\n\ntype ContrivedExampleComponmentProps = {\n  item: Item;\n  items: Item[];\n};\n</code></pre>\n<p>So, if you look at our two object examples above, we&#39;re missing something.</p>\n<ul>\n<li><code>{}</code>Â will allow for an object with any keys and any values.</li>\n<li><code>{ id: string; title: string; }</code>Â will only allow for an object withÂ <em>two</em>Â keys:Â <code>id</code>Â andÂ <code>title</code>Â as long as those values are both strings.</li>\n</ul>\n<p>But, what if we wanted to find a happy medium? What if we wanted a situation where we said, &quot;Listen, the key can beÂ _any_string and the value has to be of a certain type.</p>\n<p>That might look something like this:</p>\n<pre><code class=\"language-ts\">type ItemHash = {\n  [key: string]: Item;\n};\n</code></pre>\n<p>Or, if we wanted to say the keys are number and the values are strings, it would look like this:</p>\n<pre><code class=\"language-ts\">type Dictionary = {\n  [key: number]: string;\n};\n</code></pre>\n<p>Another way of writing either of those would be as follows:</p>\n<pre><code class=\"language-ts\">Record&lt;string, Item&gt;;\n</code></pre>\n<h2 id=\"functions\">Functions</h2>\n<p>Okay, so we tend to also pass functions around, right? What does that look like?</p>\n<pre><code class=\"language-ts\">type ContrivedExampleProps = {\n  // Does not take any arguments. Does not return anything.\n  onHover: () =&gt; void;\n  // Takes a number. Returns nothing (e.g. undefined).\n  onChange: (id: number) =&gt; void;\n  // Takes an event that is based on clicking on a button.\n  // Returns nothing.\n  onClick(event: React.MouseEvent&lt;HTMLButtonElement&gt;): void;\n};\n</code></pre>\n<p>A standalone function that you type as your declare it, is a little bit different.</p>\n<pre><code class=\"language-ts\">const add = (a: number, b: number): number =&gt; {\n  return a + b;\n};\n\nfunction subtract(a: number, b: number): number {\n  return a - b;\n}\n</code></pre>\n<p>But, you can separate the type from the function definition if you really insist.</p>\n<pre><code class=\"language-ts\">type Multiply = (a: number, b: number) =&gt; number;\n\nconst multiply: Multiply = (a, b) =&gt; a + b;\n</code></pre>\n<h2 id=\"optional-properties\">Optional properties</h2>\n<p>We covered this ? but let&#39;s add it here for the sake of making this reference complete. Adding <code>?</code> signifies that you&#39;re cool with this being <code>undefined</code>.</p>\n<pre><code class=\"language-ts\">type ContrivedProps = {\n  requiredProp: boolean;\n  optionalProp?: string;\n};\n</code></pre>\n","markdown":"Let's take a moment to look at some of the types that go along with some of the more common props that we tend to see in React applications.\n\n## Primitives\n\nFor starters, we have our basic primitives.\n\n```ts\ntype CounterProps = {\n  incident: string;\n  count: number;\n  enabled: boolean;\n};\n```\n\n## Arrays\n\nWe can also have arrays or collections of primitives.\n\n```ts\ntype GroceryListProps = {\n  items: string[];\n};\n```\n\n## Unions and intersections\n\nSometimes, we don't want to allowÂ *any*Â stringâ€”only certain strings. We can use aÂ [union type](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html)Â to represent this.\n\n```ts\ntype GroceryListProps = {\n  items: string[];\n  status: \"loading\" | \"error\" | \"success\";\n};\n```\n\n**Let the record show**: This is one of my favorite things about using TypeScript in React. I don't want to talk about how many hours of my life I've lossed due to a silly misspelling.\n\n## Objects\n\nIt's not uncommon for us to find ourselves using objects in JavaScript (ummm, TypeScript). So, what would that look like?\n\n```ts\ntype ContrivedExampleComponmentProps = {\n  anObject: object; // Useful as a placeholder.\n  anotherObject: {}; // Can have any properties and values.\n  yetAnotherObject: Record<string, string>;\n  // ðŸ‘† Takes an object where the keys are strings and so are the values.\n  item: {\n    id: string;\n    title: string;\n  };\n  items: {\n    id: string;\n    title: string;\n  }[]; // An array of objects of a certain shape.\n};\n```\n\nWe could refactor this a bit. (I know, it's a contrived example, but go along with it.)\n\n```ts\ntype Item = {\n  id: string;\n  title: string;\n};\n\ntype ContrivedExampleComponmentProps = {\n  item: Item;\n  items: Item[];\n};\n```\n\nSo, if you look at our two object examples above, we're missing something.\n\n- `{}`Â will allow for an object with any keys and any values.\n- `{ id: string; title: string; }`Â will only allow for an object withÂ *two*Â keys:Â `id`Â andÂ `title`Â as long as those values are both strings.\n\nBut, what if we wanted to find a happy medium? What if we wanted a situation where we said, \"Listen, the key can beÂ _any_string and the value has to be of a certain type.\n\nThat might look something like this:\n\n```ts\ntype ItemHash = {\n  [key: string]: Item;\n};\n```\n\nOr, if we wanted to say the keys are number and the values are strings, it would look like this:\n\n```ts\ntype Dictionary = {\n  [key: number]: string;\n};\n```\n\nAnother way of writing either of those would be as follows:\n\n```ts\nRecord<string, Item>;\n```\n\n## Functions\n\nOkay, so we tend to also pass functions around, right? What does that look like?\n\n```ts\ntype ContrivedExampleProps = {\n  // Does not take any arguments. Does not return anything.\n  onHover: () => void;\n  // Takes a number. Returns nothing (e.g. undefined).\n  onChange: (id: number) => void;\n  // Takes an event that is based on clicking on a button.\n  // Returns nothing.\n  onClick(event: React.MouseEvent<HTMLButtonElement>): void;\n};\n```\n\nA standalone function that you type as your declare it, is a little bit different.\n\n```ts\nconst add = (a: number, b: number): number => {\n  return a + b;\n};\n\nfunction subtract(a: number, b: number): number {\n  return a - b;\n}\n```\n\nBut, you can separate the type from the function definition if you really insist.\n\n```ts\ntype Multiply = (a: number, b: number) => number;\n\nconst multiply: Multiply = (a, b) => a + b;\n```\n\n## Optional properties\n\nWe covered this ? but let's add it here for the sake of making this reference complete. Adding `?` signifies that you're cool with this being `undefined`.\n\n```ts\ntype ContrivedProps = {\n  requiredProp: boolean;\n  optionalProp?: string;\n};\n```\n","slug":"commonly-used-props","title":"Commonly Used Props","section":"PropTypes","icon":"file-code","filePath":"/home/runner/work/React-with-TypeScript/React-with-TypeScript/lessons/03-PropTypes/E-commonly-used-props.md","nextSlug":"/React-with-TypeScript/lessons/children/type-the-children","prevSlug":"/React-with-TypeScript/lessons/PropTypes/solutions"}},"__N_SSG":true}