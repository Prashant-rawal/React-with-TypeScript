{"pageProps":{"post":{"attributes":{},"html":"<h1 id=\"migrating-from-proptypes\"><strong>Migrating from Proptypes</strong></h1>\n<br>\n\n<p>It turns out that in React, sometimes we pass props to our components instead of just using them as a fancy way to break up static HTML. Having my name hardcoded into the markup is cool, I guess, but it would be <em>even better</em> if we could pass a prop in there.</p>\n<p>Maybe, we do something like this:</p>\n<pre><code class=\"language-tsx\">import NameBadge from &quot;./name-badge&quot;;\n\nconst Application = () =&gt; (\n  &lt;main className=&quot;application&quot;&gt;\n    &lt;NameBadge name={&quot;Prashant&quot;} /&gt;\n  &lt;/main&gt;\n);\n\nexport default Application;\n</code></pre>\n<p>Now, if you tried that, you&#39;ll see that TypeScript is already very annoyed with you.</p>\n<p><img src=\"_attachments/invalid-props-for-name-badge.png\" alt=\"\"></p>\n<p>Okay, that&#39;s somewhat cryptic. But, we get the gist. If this was JavaScript, we could pass whatever garbage we wanted to a component. But TypeScript is telling us, &quot;Hey look, you told us that this function doesn&#39;t take any arguments and now we&#39;re passing it props? What gives?</p>\n<p>Let&#39;s do the obvious thing and update our component to take some props.</p>\n<pre><code class=\"language-tsx\">const NameBadge = ({ name }: { name: string }) =&gt; {\n  return (\n    &lt;section className=&quot;badge&quot;&gt;\n      &lt;header className=&quot;badge-header&quot;&gt;\n        &lt;h1 className=&quot;text-5xl&quot;&gt;HELLO&lt;/h1&gt;\n        &lt;p&gt;My name is…&lt;/p&gt;\n      &lt;/header&gt;\n      &lt;div className=&quot;badge-body&quot;&gt;\n        &lt;p className=&quot;badge-name&quot;&gt;{name}&lt;/p&gt;\n      &lt;/div&gt;\n      &lt;footer className=&quot;badge-footer&quot; /&gt;\n    &lt;/section&gt;\n  );\n};\n\nexport default NameBadge;\n</code></pre>\n<p>Now, we have a new issue:</p>\n<p><img src=\"_attachments/Pasted%20image%2020221106155554.png\" alt=\"\"></p>\n<p>TypeScript was able to look at the return value of the function and figure it out. But, it&#39;s not smart enough to acquiesce what the values being passed in are. We need to give is a little extra information.</p>\n<p>In the past, we might have done this with <a href=\"https://npm.im/prop-types\"><code>PropTypes</code></a>.</p>\n<pre><code class=\"language-tsx\">NameBadge.propTypes = {\n  name: PropTypes.string,\n};\n</code></pre>\n<p>In JavaScript, we&#39;ve traditionally used <code>PropTypes</code> in order to make sure that we were passing the correct types to our React components. <code>PropTypes</code> would only run at run-time and in development and would spit out console warnings in the event that the component recieved the wrong types. This was good, but we can do better with TypeScript—specifically, we can do this statically and at compile time.</p>\n<p>This means, that our application won&#39;t build if we it looks like we&#39;re going to have a problem.</p>\n<p>Basically, you might have already been doing a lot of the work with a lot less of the gain. Don&#39;t tell me I passed you the wrong types at in my browser console. Tell me in my editor while I am editing.</p>\n<h2 id=\"specifing-what-types-you-props-out-to-be\">Specifing what types you props out to be</h2>\n<p>The good news here is that now only is TypeScript <em>way</em> more thorough. It&#39;s actually a lot easy to add types to the props in your components.</p>\n<p>If these were a simpler TypeScript function, we&#39;d add a colon after the argument to specify what type it should be.</p>\n<pre><code class=\"language-ts\">const addTwo = (n: number) =&gt; n + 2;\n</code></pre>\n<p>Props are an object in TypeScript, so we need to specify what each type each key in the object should be.</p>\n<pre><code class=\"language-ts\">const NameBadge = ({ name }: { name: string }) =&gt; {\n  // …\n};\n</code></pre>\n<p>If that looks a little confusing to you compared to how simple and elegant <code>addTwo</code> was then you can go also think of it like this:</p>\n<pre><code class=\"language-tsx\">const NameBadge = (props: { name: string }) =&gt; {\n  return &lt;p&gt;{props}&lt;/p&gt;;\n};\n</code></pre>\n<p>And now it&#39;s happy with us.</p>\n<h2 id=\"specifying-types\">Specifying types</h2>\n<p>As you can imagine, this could get a little out of control if we had lots of props. So, we can also create a new prop and tell TypeScript that our component is expecting to a lot of props. Let&#39;s see what that would look like.</p>\n<p>This the idiomatic pattern that you can expect to see regularly:</p>\n<pre><code class=\"language-ts\">type NameBadgeProps = {\n  name: string;\n};\n\nconst NameBadge = ({ name }: NameBadgeProps) =&gt; {\n  // …\n};\n\nexport default NameBadge;\n</code></pre>\n<p>It&#39;s convention to just take the name of your components and tack on -<code>Props</code> on to the end. You don&#39;t have to be overly creative.</p>\n","markdown":"# **Migrating from Proptypes**\n\n<br>\n\nIt turns out that in React, sometimes we pass props to our components instead of just using them as a fancy way to break up static HTML. Having my name hardcoded into the markup is cool, I guess, but it would be _even better_ if we could pass a prop in there.\n\nMaybe, we do something like this:\n\n```tsx\nimport NameBadge from \"./name-badge\";\n\nconst Application = () => (\n  <main className=\"application\">\n    <NameBadge name={\"Prashant\"} />\n  </main>\n);\n\nexport default Application;\n```\n\nNow, if you tried that, you'll see that TypeScript is already very annoyed with you.\n\n![](_attachments/invalid-props-for-name-badge.png)\n\nOkay, that's somewhat cryptic. But, we get the gist. If this was JavaScript, we could pass whatever garbage we wanted to a component. But TypeScript is telling us, \"Hey look, you told us that this function doesn't take any arguments and now we're passing it props? What gives?\n\nLet's do the obvious thing and update our component to take some props.\n\n```tsx\nconst NameBadge = ({ name }: { name: string }) => {\n  return (\n    <section className=\"badge\">\n      <header className=\"badge-header\">\n        <h1 className=\"text-5xl\">HELLO</h1>\n        <p>My name is…</p>\n      </header>\n      <div className=\"badge-body\">\n        <p className=\"badge-name\">{name}</p>\n      </div>\n      <footer className=\"badge-footer\" />\n    </section>\n  );\n};\n\nexport default NameBadge;\n```\n\nNow, we have a new issue:\n\n![](_attachments/Pasted%20image%2020221106155554.png)\n\nTypeScript was able to look at the return value of the function and figure it out. But, it's not smart enough to acquiesce what the values being passed in are. We need to give is a little extra information.\n\nIn the past, we might have done this with [`PropTypes`](https://npm.im/prop-types).\n\n```tsx\nNameBadge.propTypes = {\n  name: PropTypes.string,\n};\n```\n\nIn JavaScript, we've traditionally used `PropTypes` in order to make sure that we were passing the correct types to our React components. `PropTypes` would only run at run-time and in development and would spit out console warnings in the event that the component recieved the wrong types. This was good, but we can do better with TypeScript—specifically, we can do this statically and at compile time.\n\nThis means, that our application won't build if we it looks like we're going to have a problem.\n\nBasically, you might have already been doing a lot of the work with a lot less of the gain. Don't tell me I passed you the wrong types at in my browser console. Tell me in my editor while I am editing.\n\n## Specifing what types you props out to be\n\nThe good news here is that now only is TypeScript _way_ more thorough. It's actually a lot easy to add types to the props in your components.\n\nIf these were a simpler TypeScript function, we'd add a colon after the argument to specify what type it should be.\n\n```ts\nconst addTwo = (n: number) => n + 2;\n```\n\nProps are an object in TypeScript, so we need to specify what each type each key in the object should be.\n\n```ts\nconst NameBadge = ({ name }: { name: string }) => {\n  // …\n};\n```\n\nIf that looks a little confusing to you compared to how simple and elegant `addTwo` was then you can go also think of it like this:\n\n```tsx\nconst NameBadge = (props: { name: string }) => {\n  return <p>{props}</p>;\n};\n```\n\nAnd now it's happy with us.\n\n## Specifying types\n\nAs you can imagine, this could get a little out of control if we had lots of props. So, we can also create a new prop and tell TypeScript that our component is expecting to a lot of props. Let's see what that would look like.\n\nThis the idiomatic pattern that you can expect to see regularly:\n\n```ts\ntype NameBadgeProps = {\n  name: string;\n};\n\nconst NameBadge = ({ name }: NameBadgeProps) => {\n  // …\n};\n\nexport default NameBadge;\n```\n\nIt's convention to just take the name of your components and tack on -`Props` on to the end. You don't have to be overly creative.\n","slug":"migrating-from-proptypes","title":"Migrating From Proptypes","section":"PropTypes","icon":"file-code","filePath":"/home/runner/work/React-with-TypeScript/React-with-TypeScript/lessons/03-PropTypes/B-migrating-from-proptypes.md","nextSlug":"/React-with-TypeScript/lessons/PropTypes/refactoring-prototypes","prevSlug":"/React-with-TypeScript/lessons/PropTypes/nameBadge"}},"__N_SSG":true}