{"pageProps":{"post":{"attributes":{},"html":"<h1 id=\"context-api\"><strong>Context Api</strong></h1>\n<p>At first glance, React&#39;s Context API behaves just like we might expect.</p>\n<pre><code class=\"language-tsx\">import { createContext } from &quot;react&quot;;\nimport { initialState } from &quot;./lib/color-reducer&quot;;\n\nconst ColorContext = createContext(initialState);\n</code></pre>\n<p>If you hover over <code>ColorContext</code>, you&#39;ll see:</p>\n<pre><code class=\"language-tsx\">const ColorContext: React.Context&lt;ColorState&gt;;\n</code></pre>\n<p>And if you <em>just</em> needed that you&#39;d be fine.</p>\n<p><img src=\"_attachments/Pasted%20image%2020221111145036.png\" alt=\"\"></p>\n<p>The problem is that a lot of the time we use the Context APi to help with state management. And part of state management is—you know—updating the state.</p>\n<p>And to update the state, you tend to use hooks. And you definitely don&#39;t have those hooks outside of components.</p>\n<p>The is futher exacerbated by the fact that you can only export <code>ColorContext</code> from the top-level of the module (e.g. <em>not</em> inside a component where you can use hooks).</p>\n<p>And so, it&#39;s a bit tempting to say that we want to do something like this:</p>\n<pre><code class=\"language-tsx\">const ColorContext = createContext&lt;{\n  state: ColorState;\n  dispatch: Dispatch&lt;ColorActions&gt;;\n}&gt;({ state: initialState });\n</code></pre>\n<p>The problem of course is that you know you&#39;re going to get yelled at for not having <code>dispatch</code> just yet.</p>\n<p><img src=\"_attachments/Pasted%20image%2020221111145603.png\" alt=\"\"></p>\n<p>One option is to make <code>dispatch</code> optional, but then you&#39;re going to have to confirm it&#39;s existence <em>every</em> time you use it—and that <em>not</em> ideal.</p>\n<pre><code class=\"language-tsx\">const ColorContext = createContext&lt;{\n  state: ColorState;\n  dispatch?: Dispatch&lt;ColorActions&gt;;\n}&gt;({ state: initialState });\n</code></pre>\n<p>We&#39;re going to arrive at a slightly better solution in a bit, but we need to learn a few more things. But, one option is that since we <em>know</em> that we&#39;re immediately going to write up <code>dispatch</code> (or, <code>useState</code>), we could tell TypeScript, &quot;Hey, trust me, I know what I&#39;m doing.&quot;</p>\n<h2 id=\"ideas-that-i-am-not-willing-to-entertain\">Ideas that I am not willing to entertain</h2>\n<ul>\n<li><strong>Using <code>any</code></strong>: This will opt us out of the whole reason we&#39;re using TypeScript in the first place.</li>\n</ul>\n<h2 id=\"an-escape-hatch\">An escape hatch</h2>\n<p>This is an escape hatch that should fill you with an icky feeling, but it&#39;s mostly okay in this particular case. We can assert that an object meets a given type—even if TypeScript doesn&#39;t think that it does.</p>\n<p>We did this already in <code>src/index.tsx</code></p>\n<pre><code class=\"language-tsx\">const root = ReactDOM.createRoot(\n  document.getElementById(&quot;root&quot;) as HTMLElement\n);\n</code></pre>\n<p>See that <code>as HTMLElement</code>. Yea, like there is a chance that it&#39;s not on the page. <code>document.getElementById()</code> handles that telling you that it <em>might</em> return <code>undefined</code>.</p>\n<p>But, we <em>know</em> it&#39;s on the page, so we told TypeScript that it&#39;s cool. We can do the same thing here too.</p>\n<pre><code class=\"language-ts\">const ColorContext = createContext({ state: initialState } as {\n  state: ColorState;\n  dispatch: Dispatch&lt;ColorActions&gt;;\n});\n</code></pre>\n<!-- If this bother's you, we'll look at [a different—and arguably, better—way](createContext.md) to deal with this after we explore [generics](Generics.md) in a bit. -->\n\n<p>Now, we can go the rest of the way with the normal ceremony that we&#39;re used to.</p>\n<pre><code class=\"language-ts\">import { createContext, Dispatch, PropsWithChildren, useReducer } from &quot;react&quot;;\nimport colorReducer, { initialState } from &quot;./lib/color-reducer&quot;;\n\nexport const ColorContext = createContext({ state: initialState } as {\n  state: ColorState;\n  dispatch: Dispatch&lt;ColorActions&gt;;\n});\n\nexport const ColorProvider = ({ children }: PropsWithChildren) =&gt; {\n  const [state, dispatch] = useReducer(colorReducer, initialState);\n\n  return (\n    &lt;ColorContext.Provider value={{ state, dispatch }}&gt;\n      {children}\n    &lt;/ColorContext.Provider&gt;\n  );\n};\n</code></pre>\n<p>Don&#39;t forget to wrap your application in</p>\n<p>The important thing to note is that despite our sneaky move, our type system holds up. We don&#39;t have to verify that <code>dispatch</code> exists constantly and when we go to use <code>state</code> and <code>dispatch</code>, everything will have the correct types.</p>\n<h2 id=\"using-the-context-in-your-components\">Using the context in your components</h2>\n<p>And again, we get a lot of the types for free. Let&#39;s take it for a spin in <code>src/components/shared/color-change-swatch.tsx</code>.</p>\n<pre><code class=\"language-tsx\">import clsx from &quot;clsx&quot;;\nimport { MouseEventHandler, useContext } from &quot;react&quot;;\nimport { ColorContext } from &quot;../../context&quot;;\nimport Button from &quot;./button&quot;;\n\ntype ColorChangeSwatchProps = {\n  hexColor: string;\n  className?: string;\n  onClick?: MouseEventHandler&lt;HTMLButtonElement&gt;;\n};\n\nconst ColorChangeSwatch = ({\n  hexColor,\n  className,\n  onClick,\n}: ColorChangeSwatchProps) =&gt; {\n  const { dispatch } = useContext(ColorContext);\n\n  return (\n    &lt;Button\n      className={clsx(\n        &quot;border-2 border-slate-900 transition-shadow duration-200 ease-in hover:shadow-xl&quot;,\n        className\n      )}\n      style={{ backgroundColor: hexColor }}\n      onClick={() =&gt;\n        dispatch({ type: &quot;update-hex-color&quot;, payload: { hexColor } })\n      }\n    &gt;\n      {hexColor}\n    &lt;/Button&gt;\n  );\n};\n\nexport default ColorChangeSwatch;\n</code></pre>\n<p>We can and should unwind the passing through of the <code>onClick</code> prop, but it&#39;s not bothering anyone for now and I&#39;ll probably just do that behind the seens as not to waste your precious time.</p>\n<h2 id=\"wiring-up-our-new-state\">Wiring up our new state</h2>\n<p>Now, it both works and it doesn&#39;t work at the same time. It totally works, but <code>src/components/application.tsx</code> is using a <em>different</em> reducer right now.</p>\n<p>This is an easy fix:</p>\n<pre><code class=\"language-tsx\">const Application = () =&gt; {\n  const { state, dispatch } = useContext(ColorContext);\n  const hexColor = state.hexColor;\n\n  return (\n    &lt;div className=&quot;grid max-w-3xl grid-cols-1 gap-8 p-8 pb-40 mx-auto dark:bg-slate-900 dark:text-white sm:grid-cols-2&quot;&gt;\n      &lt;ColorPicker\n        hexColor={hexColor}\n        onChange={(e) =&gt;\n          dispatch({\n            type: &quot;update-hex-color&quot;,\n            payload: { hexColor: e.target.value },\n          })\n        }\n      /&gt;\n      &lt;AdjustColors hexColor={hexColor} dispatch={dispatch} /&gt;\n      &lt;RelatedColors hexColor={hexColor} /&gt;\n      &lt;SavedColors hexColor={hexColor} dispatch={dispatch} /&gt;\n    &lt;/div&gt;\n  );\n};\n</code></pre>\n","markdown":"# **Context Api**\n\nAt first glance, React's Context API behaves just like we might expect.\n\n```tsx\nimport { createContext } from \"react\";\nimport { initialState } from \"./lib/color-reducer\";\n\nconst ColorContext = createContext(initialState);\n```\n\nIf you hover over `ColorContext`, you'll see:\n\n```tsx\nconst ColorContext: React.Context<ColorState>;\n```\n\nAnd if you _just_ needed that you'd be fine.\n\n![](_attachments/Pasted%20image%2020221111145036.png)\n\nThe problem is that a lot of the time we use the Context APi to help with state management. And part of state management is—you know—updating the state.\n\nAnd to update the state, you tend to use hooks. And you definitely don't have those hooks outside of components.\n\nThe is futher exacerbated by the fact that you can only export `ColorContext` from the top-level of the module (e.g. _not_ inside a component where you can use hooks).\n\nAnd so, it's a bit tempting to say that we want to do something like this:\n\n```tsx\nconst ColorContext = createContext<{\n  state: ColorState;\n  dispatch: Dispatch<ColorActions>;\n}>({ state: initialState });\n```\n\nThe problem of course is that you know you're going to get yelled at for not having `dispatch` just yet.\n\n![](_attachments/Pasted%20image%2020221111145603.png)\n\nOne option is to make `dispatch` optional, but then you're going to have to confirm it's existence _every_ time you use it—and that _not_ ideal.\n\n```tsx\nconst ColorContext = createContext<{\n  state: ColorState;\n  dispatch?: Dispatch<ColorActions>;\n}>({ state: initialState });\n```\n\nWe're going to arrive at a slightly better solution in a bit, but we need to learn a few more things. But, one option is that since we _know_ that we're immediately going to write up `dispatch` (or, `useState`), we could tell TypeScript, \"Hey, trust me, I know what I'm doing.\"\n\n## Ideas that I am not willing to entertain\n\n- **Using `any`**: This will opt us out of the whole reason we're using TypeScript in the first place.\n\n## An escape hatch\n\nThis is an escape hatch that should fill you with an icky feeling, but it's mostly okay in this particular case. We can assert that an object meets a given type—even if TypeScript doesn't think that it does.\n\nWe did this already in `src/index.tsx`\n\n```tsx\nconst root = ReactDOM.createRoot(\n  document.getElementById(\"root\") as HTMLElement\n);\n```\n\nSee that `as HTMLElement`. Yea, like there is a chance that it's not on the page. `document.getElementById()` handles that telling you that it _might_ return `undefined`.\n\nBut, we _know_ it's on the page, so we told TypeScript that it's cool. We can do the same thing here too.\n\n```ts\nconst ColorContext = createContext({ state: initialState } as {\n  state: ColorState;\n  dispatch: Dispatch<ColorActions>;\n});\n```\n\n<!-- If this bother's you, we'll look at [a different—and arguably, better—way](createContext.md) to deal with this after we explore [generics](Generics.md) in a bit. -->\n\nNow, we can go the rest of the way with the normal ceremony that we're used to.\n\n```ts\nimport { createContext, Dispatch, PropsWithChildren, useReducer } from \"react\";\nimport colorReducer, { initialState } from \"./lib/color-reducer\";\n\nexport const ColorContext = createContext({ state: initialState } as {\n  state: ColorState;\n  dispatch: Dispatch<ColorActions>;\n});\n\nexport const ColorProvider = ({ children }: PropsWithChildren) => {\n  const [state, dispatch] = useReducer(colorReducer, initialState);\n\n  return (\n    <ColorContext.Provider value={{ state, dispatch }}>\n      {children}\n    </ColorContext.Provider>\n  );\n};\n```\n\nDon't forget to wrap your application in\n\nThe important thing to note is that despite our sneaky move, our type system holds up. We don't have to verify that `dispatch` exists constantly and when we go to use `state` and `dispatch`, everything will have the correct types.\n\n## Using the context in your components\n\nAnd again, we get a lot of the types for free. Let's take it for a spin in `src/components/shared/color-change-swatch.tsx`.\n\n```tsx\nimport clsx from \"clsx\";\nimport { MouseEventHandler, useContext } from \"react\";\nimport { ColorContext } from \"../../context\";\nimport Button from \"./button\";\n\ntype ColorChangeSwatchProps = {\n  hexColor: string;\n  className?: string;\n  onClick?: MouseEventHandler<HTMLButtonElement>;\n};\n\nconst ColorChangeSwatch = ({\n  hexColor,\n  className,\n  onClick,\n}: ColorChangeSwatchProps) => {\n  const { dispatch } = useContext(ColorContext);\n\n  return (\n    <Button\n      className={clsx(\n        \"border-2 border-slate-900 transition-shadow duration-200 ease-in hover:shadow-xl\",\n        className\n      )}\n      style={{ backgroundColor: hexColor }}\n      onClick={() =>\n        dispatch({ type: \"update-hex-color\", payload: { hexColor } })\n      }\n    >\n      {hexColor}\n    </Button>\n  );\n};\n\nexport default ColorChangeSwatch;\n```\n\nWe can and should unwind the passing through of the `onClick` prop, but it's not bothering anyone for now and I'll probably just do that behind the seens as not to waste your precious time.\n\n## Wiring up our new state\n\nNow, it both works and it doesn't work at the same time. It totally works, but `src/components/application.tsx` is using a _different_ reducer right now.\n\nThis is an easy fix:\n\n```tsx\nconst Application = () => {\n  const { state, dispatch } = useContext(ColorContext);\n  const hexColor = state.hexColor;\n\n  return (\n    <div className=\"grid max-w-3xl grid-cols-1 gap-8 p-8 pb-40 mx-auto dark:bg-slate-900 dark:text-white sm:grid-cols-2\">\n      <ColorPicker\n        hexColor={hexColor}\n        onChange={(e) =>\n          dispatch({\n            type: \"update-hex-color\",\n            payload: { hexColor: e.target.value },\n          })\n        }\n      />\n      <AdjustColors hexColor={hexColor} dispatch={dispatch} />\n      <RelatedColors hexColor={hexColor} />\n      <SavedColors hexColor={hexColor} dispatch={dispatch} />\n    </div>\n  );\n};\n```\n","slug":"the-context-api","title":"The Context Api","section":"Context Api","icon":"copyright","filePath":"/home/runner/work/React-with-TypeScript/React-with-TypeScript/lessons/07-context-api/A-the-context-api.md","nextSlug":"/React-with-TypeScript/lessons/context-api/context-api-exercise","prevSlug":"/React-with-TypeScript/lessons/Reducers/Typing-action-and-reducers-solution"}},"__N_SSG":true}